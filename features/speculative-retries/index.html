<!DOCTYPE html>
<html lang="en">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="DataStax C# Driver for Apache Cassandra">
    <meta name="author" content="DataStax">

    <title>DataStax C# Driver - Speculative query execution</title>

    <link rel="icon" href="../../favicon.ico">
    <link rel="apple-touch-icon" href="../../favicon.png">
    <link href="../../css/style.css" rel="stylesheet">
    <link href="../../css/pygments.css" rel="stylesheet">
    <link href="../../css/hotkeys.css" rel="stylesheet">

    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body ng-app="docs" data-spy="scroll" data-target="#table-of-contents" data-offset="69">
    <header class="container-fluid navbar">
      <div class="row">
        <div class="col-sm-4">
          <a class="navbar-brand" href="../../"><img alt="Brand" src="../../img/logo.png">DataStax C# Driver</a>
        </div>
        <div class="col-md-4 col-md-offset-4">
          <div class="row">
            <div class="col-md-12">
              <ul class="list-inline" role="nav">
                <li><a href="https://academy.datastax.com/" class="navbar-link">DataStax Academy</a></li>
                <li><a href="http://www.datastax.com/dev/blog" class="navbar-link">Tech Blog</a></li>
                <li><a href="http://www.datastax.com/what-we-offer/products-services/support" class="navbar-link">Support</a></li>
              </ul>
            </div>
          </div>
          <div class="row">
            <div class="col-md-8">
              <form id="search" class="form-search dropdown visible-lg-block" ng-controller="search" ng-class="{open: hasResults}" role="search" ng-submit="submit()" data-spy="affix" data-offset-top="130">
                <div class="form-group has-feedback">
                  <input type="search" class="form-control input-sm mousetrap" placeholder="Search..." ng-model="q" ng-change="search('v3.0')" ng-disabled="!searchReady" disabled data-hotkey="{down: moveDown, up: moveUp, esc: reset}" data-search>
                </div>
                <ul class="dropdown-menu search-results" role="menu">
                  <li ng-repeat="result in results" ng-class="{'bg-warning': $index == current}"><a ng-href="{{basePath}}{{result.path}}"><span ng-bind-html="summary(result)"></span></a></li>
                </ul>
              </form>
            </div>
            <div class="col-md-4">
              <a href="http://www.datastax.com/download" class="btn btn-primary btn-sm">Download</a>
            </div>
          </div>
        </div>
      </div>
      <div class="row crumbs-wrapper">
        <div class="col-md-12">
          <nav id="crumbs" data-spy="affix" data-offset-top="130">
            <ol class="breadcrumb">
              
              
              
              
              <li><a href="../../">Home</a></li>
              
              
              
              
              
              <li><a href="../">Features</a></li>
              
              
              
              
              
              <li class="active">Speculative query execution</li>
              <li class="dropdown" id="table-of-contents">
                <div class="btn-group">
                  <button id="current-section" type="button" class="btn btn-default btn-sm dropdown-toggle" data-toggle="dropdown">
                    Jump to&#8230; <span class="caret"></span><span class="sr-only">Table of Contents</span>
                  </button>
                  <ul class="dropdown-menu nav nav-pills nav-stacked">
                    <li><a href="#speculative-query-execution">Page Top <span class="glyphicon glyphicon-chevron-up" aria-hidden="true"></span></a></li>
<li><a href="#query-idempotence">Query idempotence
</a></li>
<li><a href="#enabling-speculative-execution">Enabling speculative execution
</a></li>
<li><a href="#how-speculative-executions-affect-retries">How speculative executions affect retries
</a></li>
<li><a href="#tuning-and-practical-details">Tuning and practical details
</a></li>
                  </ul>
                </div>
              </li>
              
              
              
            </ol>
          </nav>
        </div>
      </div>
    </header>

    <div class="container-fluid" id="content">
      <div class="row">
        <div class="col-md-3">
          <div id="navigation" class="side-nav" role="tablist" aria-multiselectable="true">
            <h3>Contents</h3>
            <ul class="nav nav-pills nav-stacked">
  
  
  
  <li>
    <a href="../../faq/">FAQ <small>page</small></a>
  </li>
  
  
  
  
  <li class="active">
    <a href="../">Features <small>page</small></a>
    <ul class="nav nav-pills nav-stacked">
  
  
  
  <li>
    <a href="../address-resolution/">Address resolution <small>page</small></a>
  </li>
  
  
  
  
  <li>
    <a href="../automatic-failover/">Automatic failover <small>page</small></a>
  </li>
  
  
  
  
  <li>
    <a href="../datatypes/">CQL data types to C# types <small>page</small></a>
  </li>
  
  
  
  
  <li>
    <a href="../connection-heartbeat/">Connection heartbeat <small>page</small></a>
  </li>
  
  
  
  
  <li>
    <a href="../connection-pooling/">Connection pooling <small>page</small></a>
  </li>
  
  
  
  
  <li>
    <a href="../components/">Driver components <small>page</small></a>
  </li>
  
  
  
  
  <li>
    <a href="../parametrized-queries/">Parameterized queries <small>page</small></a>
  </li>
  
  
  
  
  <li>
    <a href="../query-warnings/">Query warnings <small>page</small></a>
  </li>
  
  
  
  
  <li>
    <a href="../paging/">Result paging <small>page</small></a>
  </li>
  
  
  
  
  <li>
    <a href="../routing-queries/">Routing queries <small>page</small></a>
  </li>
  
  
  
  
  <li class="active">
    <a href="./" class="current">Speculative query execution <small>page</small></a>
    
  </li>
  
  
  
  
  <li>
    <a href="../tuning-policies/">Tuning policies <small>page</small></a>
  </li>
  
  
  
  
  <li>
    <a href="../udfs/">User-defined functions and aggregates <small>page</small></a>
  </li>
  
  
  
  
  <li>
    <a href="../udts/">User-defined types <small>page</small></a>
  </li>
  
  
</ul>

  </li>
  
  
</ul>

          </div>
        </div>
        <div class="col-md-9 content">
          

<h1 id="speculative-query-execution" class="target">Speculative query execution<a class="anchor" href="#speculative-query-execution" aria-hidden="true"><span class="glyphicon glyphicon-link"></span></a>
</h1>

<p>Sometimes a Cassandra node might be experiencing difficulties (for example, long GC pause) and take longer than
usual to reply. Queries sent to that node experience bad latency. One thing we can do to improve that is pre-emptively
start a second execution of the query against another node, before the first node has replied or errored out.
If that second node replies faster, we can send the response back to the client (we also cancel the first query):</p>
<pre><code>client           driver          exec1  exec2
--+----------------+--------------+------+---
  | execute(query) |
  |---------------&gt;|
  |                | query host1
  |                |-------------&gt;|
  |                |              |
  |                |              |
  |                |     query host2
  |                |--------------------&gt;|
  |                |              |      |
  |                |              |      |
  |                |     host2 replies   |
  |                |&lt;--------------------|
  |   complete     |              |
  |&lt;---------------|              |
  |                | cancel       |
  |                |-------------&gt;|
</code></pre>
<p>Or the first node could reply just after the second execution was started. In this case, we cancel the second execution.
In other words, whichever node replies faster wins and completes the client query:</p>
<pre><code>client           driver          exec1  exec2
--+----------------+--------------+------+---
  | execute(query) |
  |---------------&gt;|
  |                | query host1
  |                |-------------&gt;|
  |                |              |
  |                |              |
  |                |     query host2
  |                |--------------------&gt;|
  |                |              |      |
  |                |              |      |
  |                | host1 replies|      |
  |                |&lt;-------------|      |
  |   complete     |                     |
  |&lt;---------------|                     |
  |                | cancel              |
  |                |--------------------&gt;|
</code></pre>
<p>Speculative executions are disabled by default. The following sections cover the practical details and how to
enable them.</p>

<h2 id="query-idempotence" class="target">Query idempotence<a class="anchor" href="#query-idempotence" aria-hidden="true"><span class="glyphicon glyphicon-link"></span></a>
</h2>

<p>One important aspect to consider is whether queries are idempotent, (that is, whether they can be applied multiple
times without changing the result beyond the initial application). If a query is not idempotent, the driver never
schedules speculative executions for it, because there is no way to guarantee that only one node will apply the
mutation.</p>

<p>Examples of queries that are not idempotent are:</p>

<ul>
<li>counter operations</li>
<li>prepending or appending to a list column</li>
<li>using non-idempotent CQL functions, like <code>now()</code> or <code>uuid()</code>
</li>
</ul>

<p>In the driver, this is determined by <a href="http://docs.datastax.com/en/latest-csharp-driver-api/html/P_Cassandra_IStatement_IsIdempotent.htm"><code>Statement.IsIdempotent()</code></a>. Because the driver does not parse
query strings, in most cases, it has no information about what the query actually does. Therefore, for all other types
of statements, it defaults to <code>false</code>. You must set it manually with one of the mechanisms described below.</p>

<p>You can override the value on each statement:</p>
<pre class="highlight"><code><span class="n">var</span> <span class="n">s</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SimpleStatement</span><span class="p">(</span><span class="s">"SELECT * FROM users WHERE id = 1"</span><span class="p">);</span>
<span class="n">s</span><span class="p">.</span><span class="nf">SetIdempotence</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
</code></pre>
<p>Note: This also works for built statements (and it overrides the computed value). Additionally, if you know for a fact
that your application does not use any of the non-idempotent CQL queries listed above, you can change the default
cluster-wide:</p>
<pre class="highlight"><code><span class="c1">// Make all statements idempotent by default:
</span><span class="n">var</span> <span class="n">cluster</span> <span class="p">=</span> <span class="n">Cluster</span><span class="p">.</span><span class="nf">Builder</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">AddContactPoint</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">WithQueryOptions</span><span class="p">(</span><span class="k">new</span> <span class="nf">QueryOptions</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">SetDefaultIdempotence</span><span class="p">(</span><span class="k">true</span><span class="p">))</span>
    <span class="p">.</span><span class="nf">Build</span><span class="p">();</span>
</code></pre>
<h2 id="enabling-speculative-execution" class="target">Enabling speculative execution<a class="anchor" href="#enabling-speculative-execution" aria-hidden="true"><span class="glyphicon glyphicon-link"></span></a>
</h2>

<p>Speculative executions are controlled by an instance of <code>ISpeculativeExecutionPolicy</code> provided when initializing the
Cluster. This policy defines the threshold after which a new speculative execution is triggered.</p>

<p>The driver provides a <code>ConstantSpeculativeExecutionPolicy</code> that schedules a given number of speculative executions,
separated by a fixed delay.</p>

<p>This simple policy uses a constant threshold:</p>
<pre class="highlight"><code><span class="n">var</span> <span class="n">cluster</span> <span class="p">=</span> <span class="n">Cluster</span><span class="p">.</span><span class="nf">Builder</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">AddContactPoint</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">WithSpeculativeExecutionPolicy</span><span class="p">(</span>
        <span class="k">new</span> <span class="nf">ConstantSpeculativeExecutionPolicy</span><span class="p">(</span>
            <span class="m">500</span><span class="p">,</span> <span class="c1">// delay before a new execution is launched
</span>            <span class="m">2</span>    <span class="c1">// maximum number of additional executions
</span>        <span class="p">))</span>
    <span class="p">.</span><span class="nf">Build</span><span class="p">();</span>
</code></pre>
<p>Given the configuration above, an idempotent query would be handled this way:</p>

<ul>
<li>start the initial execution at t0</li>
<li>if no response has been received at t0 + 500 milliseconds, start a speculative execution on another node</li>
<li>if no response has been received at t0 + 1000 milliseconds, start another speculative execution on a third node</li>
</ul>

<p>As with all policies, you are free to provide your own by implementing the <code>ISpeculativeExecutionPolicy</code> interface.</p>

<h2 id="how-speculative-executions-affect-retries" class="target">How speculative executions affect retries<a class="anchor" href="#how-speculative-executions-affect-retries" aria-hidden="true"><span class="glyphicon glyphicon-link"></span></a>
</h2>

<p>Regardless of speculative executions, the driver has a retry mechanism:</p>

<ul>
<li>on an internal error, it will try the next host</li>
<li>if the consistency level cannot be reached (for example, unavailable error or read or write timeout), it delegates
the decision to the RetryPolicy, which might trigger a retry on the same host</li>
</ul>

<p>Turning speculative executions on does not change this behavior. Each parallel execution trigger retries independently:</p>
<pre><code>client           driver          exec1  exec2
--+----------------+--------------+------+---
  | execute(query) |
  |---------------&gt;|
  |                | query host1
  |                |-------------&gt;|
  |                |              |
  |                | unavailable  |
  |                |&lt;-------------|
  |                |
  |                |retry at lower CL
  |                |-------------&gt;|
  |                |              |
  |                |     query host2
  |                |--------------------&gt;|
  |                |              |      |
  |                |     server error    |
  |                |&lt;--------------------|
  |                |              |
  |                |   retry on host3
  |                |--------------------&gt;|
  |                |              |      |
  |                | host1 replies|      |
  |                |&lt;-------------|      |
  |   complete     |                     |
  |&lt;---------------|                     |
  |                | cancel              |
  |                |--------------------&gt;|
</code></pre>
<p>The only impact is that all executions of the same query always share the same query plan, so each host is used by at
most one execution.</p>

<h2 id="tuning-and-practical-details" class="target">Tuning and practical details<a class="anchor" href="#tuning-and-practical-details" aria-hidden="true"><span class="glyphicon glyphicon-link"></span></a>
</h2>

<p>The goal of speculative executions is to improve overall latency (the time between execute(query) and complete in the
diagrams above) at high percentiles. On the flipside, they cause the driver to send more individual requests, so
throughput does not necessarily improve.</p>

<p>One side-effect of speculative executions is that many requests are cancelled, which can lead to a phenomenon called
stream id exhaustion: each TCP connection can handle multiple simultaneous requests, identified by a unique
number called stream id. When a request gets cancelled, we can’t reuse its stream id immediately because we might
still receive a response from the server later. If this happens often, the number of available stream ids diminishes
over time, and when it goes below a given threshold we close the connection and create a new one. If requests are often
cancelled, so will see connections being recycled at a high rate.</p>

<p>This problem is more likely to happen with Cassandra version 2.0 or below (version 1 or 2 of the native protocol),
because each TCP connection only has 128 stream ids. With following versions of Cassandra, there are 32K stream ids per
connection, so higher cancellation rates can be sustained.</p>

<p>Another issue that might arise is that you get unintuitive results because of request ordering. Suppose you run the
following query with speculative executions enabled:</p>
<pre><code>insert into my_table (k, v) values (1, 1);
</code></pre>
<p>The first execution is a bit too slow, so a second execution gets triggered. Finally, the first execution completes,
so the client code gets back an acknowledgement, and the second execution is cancelled. However, cancelling only means
that the driver stops waiting for the server’s response, the request could still be on the wire; let us assume that
this is the case. Now you run the following query, which completes successfully:</p>
<pre><code>delete from my_table where k = 1;
</code></pre>
<p>But now the second execution of the first query finally reaches its target node, which applies the mutation. The row
that you’ve just deleted is back! The workaround is to use a timestamp with your queries:</p>
<pre><code>insert into my_table (k, v) values (1, 1) USING TIMESTAMP 1432764000;
</code></pre>
<p>If you’re using Cassandra 2.1 and above, you can use client-side timestamps with the method
<a href="http://docs.datastax.com/en/latest-csharp-driver-api/html/M_Cassandra_Statement_SetTimestamp.htm">Statement.SetTimestamp()</a>.</p>


        </div>
      </div>
    </div>

    
    <footer class="container text-muted">
      <ul class="list-inline">
      
        
        <li>
          <a href="https://github.com/datastax/csharp-driver/">Code</a>
        </li>
      
        <li>·</li>
        <li>
          <a href="http://datastax.github.io/csharp-driver/">Docs</a>
        </li>
      
        <li>·</li>
        <li>
          <a href="http://docs.datastax.com/en/latest-csharp-driver-api/html/N_Cassandra.htm">API docs</a>
        </li>
      
        <li>·</li>
        <li>
          <a href="https://datastax-oss.atlassian.net/projects/CSHARP/issues">Issues</a>
        </li>
      
        <li>·</li>
        <li>
          <a href="https://groups.google.com/a/lists.datastax.com/forum/#!forum/csharp-driver-user">Mailing List</a>
        </li>
      
        <li>·</li>
        <li>
          <a href="irc://irc.freenode.net/datastax-drivers">IRC Channel</a>
        </li>
      
        <li>·</li>
        <li>
          <a href="https://www.nuget.org/packages/CassandraCSharpDriver">Nuget</a>
        </li>
      
      </ul>
    </footer>
    

    <script src="../../js/jquery.js"></script>
    <script src="../../js/bootstrap.js"></script>
    <script src="../../js/angular.js"></script>
    <script src="../../js/mousetrap.js"></script>
    <script src="../../js/hotkeys.js"></script>
    <script src="../../js/ZeroClipboard.js"></script>
    <script src="../../js/lunr.js"></script>
    <script src="../../js/app.js"></script>
  </body>
</html>
